# **정렬 알고리즘 성능 분석 및 비교**
## **진행 방식**
- 각 정렬의 입력 데이터 수는 [32, 64, 128, 256, ..., 1048576] (2의 20승까지)로 진행.  

- 정렬된 데이터, 역정렬 데이터, 랜덤 데이터 세 가지의 경우에 대한 알고리즘을 수행.  

- 측정한 수행시간을 엑셀을 활용하여 그래프로 표현.

### **버블 정렬**  

![버블](https://user-images.githubusercontent.com/101345032/166897149-56ae801a-174f-4695-8a0d-49df937114b7.PNG)  

버블정렬은 for문이 진행되며 for문 한번당 N-1번, N-2번 ,... , 1번 비교 되며, 이는O(N-1) + O(N-2) + O(N-3) + ... + O(1) = O((N-1)N/2) ≒ O(N^2), 버블정렬의 시간복잡도는 O(N^2) 이다.  

정렬된 데이터나 역정렬 데이터에 비해, 랜덤 데이터가 자리바꿈을 많이 요구해 랜덤 데이터의 수행시간이 가장 길었다.

### **삽입 정렬**
![삽입](https://user-images.githubusercontent.com/101345032/166897158-02853859-acd9-4f30-8006-2e6cd670b47a.PNG) 

삽입정렬은 for문이 N-1번 수행될때, while문은 i = 1일때 1번, i = 2일때 2번,...,최대 N-1번 수행된다. 따라서 O(N(N-1)/2) ≒ O(N^2), 삽입정렬의 시간복잡도는 O(N^2)이다.   

삽입정렬은 정렬이 되어있는 부분은 넘어가고 정렬이 안된 부분부터 정렬하기 때문에 정렬이 되어 있는 데어터들에 한해 성능이 좋다. 랜덤과 역정렬에비해 정렬된 데이터가 확연히 좋은 성능을 보여준다.

### **선택 정렬**
![선택](https://user-images.githubusercontent.com/101345032/166897160-2ea7ed84-6e76-4c47-a234-a30b9364dff8.PNG)

선택 정렬은 for문이 N-1번 수행될때, 그 안의 for문이 i = 1일때 N-1번, i = 2일때 N-2번, ..., 총 N(N-1)/2이다. 따라서  O(N(N-1)/2) ≒ O(N^2), 선택정렬의 시간복잡도는 O(N^2)이다.

### **쉘 정렬**
![쉘](https://user-images.githubusercontent.com/101345032/166897162-b1630b29-4dad-41e6-b4ef-ebedc2a38fda.PNG)

쉘 정렬은 삽입정렬을 일정한 간격에 따라 진행하기 때문에, 간격 선정에 따라 성능이 좌우된다. 최악의 경우 for문과 while문에 의해 O(N^2)가 된다. 

히바드(Hibbard)의 간격(2^k-1,...,7,5,3,1)을 사용하면 O(N^1.5)가 된다. 최선의 경우 O(N^1.25)가 된다.

### **힙 정렬**
![힙](https://user-images.githubusercontent.com/101345032/166897165-f5fc71a5-54b6-42a8-99cc-53ad93a2429b.PNG)

힙 정렬은 완전 이진트리에 데이터 값들을 넣고, Downheap을 활용해 데이터값을 하나씩 빼 데이터들을 정렬시킨다.  

따라서 힙 구조를 만드는데에 O(N), for문을 N-1번 수행하며, 힙의 높이가 log₂N을 넘지 않아 각각의 for문에서 log N번 수행한다. 따라서 시간복잡도는 O(N) + O(log N) * (N-1) = O(NlogN)이다.

### **퀵 정렬**
![퀵](https://user-images.githubusercontent.com/101345032/166905456-1675e676-b7fd-4f91-9661-fb21901e9de6.PNG)

퀵 정렬은 분할 정복 알고리즘으로 피봇을 설정해 피봇 좌,우로 구간을 나누어 또다시 퀵정렬을 재귀하여 수행한다.

따라서 퀵 정렬은 피봇에 따라 성능이 좌우된다. 최악의 경우 데이터 값이 N일때 O(N-1) + O(N-2) + ... + O(1) = O(N(N-1)/2) ≒ O(N^2) 가 된다.  
최선의 경우 피봇을 중앙값으로 설정해 데이터값들을 이진트리와 비슷하게 2등분으로 분할하는 경우이다. 비교 횟수 O(N)를 이진트리의 높이 O(log₂N) 만큼 반복하여 O(N) * O(log₂N) = O(Nlog₂N)이다.